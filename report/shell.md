## Shell

### 总述

shell模块是用来实现和用户的**命令行交互**界面的。

在设计这个模块的过程中，我们不仅要考虑界面的**稳定性**（例如不能因为程序出错而意外结束进程），还要考虑**美观度**（例如我们实现了输出文字的颜色、加粗等样式），以及良好的**交互**（例如易懂的报错信息）。

### 用户输入数据的读取

通过一个while死循环，实现一直监听用户输入的数据，并且在得到`;`字符后把本次读取到的字符串合并成一个命令，发送给`core`模块。这里需要说明的是，**并非**所有的命令都是交由`core`模块处理的，两个特例是：

1. execfile命令
2. quit命令

### 从文件中读取命令

当用户输入execfile命令时，shell会把用户输入的文件路径提取出来并且打开相应的文件，读取并执行命令。

然而，有时候，会出现**一个文件中包含execfile命令**的情况，为了允许这种情况的发生，我们把`execfile`写成了一个函数，从而利用**递归调用**来实现这个功能。

除此以外，在从一个文件A中调用execfile命令去执行文件B中的命令时，考虑到文件B的路径应该是**相对于**文件A所在的路径的，因此我们会先利用正则表达式提取出文件A的前缀路径和文件B的相对路径做合并，然后再去打开文件B：

```python
execFilePath = re.sub(' *;', '', re.sub('^execfile +', '', command))
execFilePath = re.sub('/[^/]+$','/',filePath)+execFilePath
execFromFile(execFilePath)
```

### 查询结果输出

shell模块调用core模块的`execute()`函数，会得到一个**字典**，这个result dict的格式如下：

```json
{
  status: 'success' | 'error',
  payload: ...
}
```

因此，根据status和payload的不同，查询结果输出分为**三种**：

1. 成功文字信息
2. 表格信息
3. 错误文字信息

其中输出表格略微有点繁琐，其他两种情况都很好处理。

输出数据时，使用的是`print`函数通过`end`参数，来控制是否自动换行。

### 执行时间的计算

通过Python的标准库`time`，可以实现对查询执行时间的计算。

只需要在开始调用`core.execute()`之前记录开始时间：`timeStart=time.time()`，在查询执行完毕后记录结束时间，二者作差，即可得出查询语句执行的总时间。

需要说明的是，由于`outputResult()`是在`timeElapsed=time.time()-timeStart`语句之后执行的，因此最终计算出的执行时间是不包括输出数据用时在内的。